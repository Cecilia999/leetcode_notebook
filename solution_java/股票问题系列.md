# 股票问题系列

## 121.买卖一次

## 122. 买卖多次

1. 状态定义
   状态 dp[i][j] 定义如下：
   dp[i][j] 表示到下标为 i 的这一天，持股状态为 j 时，我们手上拥有的最大现金数。

   注意：限定持股状态为 j 是为了方便推导状态转移方程，这样的做法满足 **无后效性**。

   其中：

   - 第一维 i 表示下标为 i 的那一天（ 具有前缀性质，即考虑了之前天数的交易 ）；
   - 第二维 j 表示下标为 i 的那一天是持有股票，还是持有现金。这里 0 表示持有现金（cash），1 表示持有股票（stock）。

2. 状态转移方程

   - 状态从持有现金（cash）开始，到最后一天我们关心的状态依然是持有现金（cash），即 dp[length-1][0];
   - 第 i 天可能的操作：**买入、卖出、休息**。并不知道哪个操作是最好的，但是可以通过计算得到选择每个操作可以得到的最大收益。
     - 第 i 天手上是现金，要么是第 i-1 天手上是现金且休息，要么是第 i-1 天手上是股票然后卖出
       dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i]);
     - 第 i 天手上是股票，要么第 i-1 天手术是股票且休息，要么第 i-1 天手上是现金然后买入
       dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-prices[i]);

3. 确定初始值

   起始的时候：

   - 如果什么都不做，dp[0][0] = 0；
   - 如果持有股票，当前拥有的现金数是当天股价的相反数，即 dp[0][1] = -prices[i]；

4. 确定输出值
   终止的时候，上面也分析了，输出 dp[length - 1][0]，因为一定有 dp[length - 1][0] > dp[length - 1][1]。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][2];

        //确定起始值,第一天不买入 vs 第一天买入
        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        for(int i=1; i<prices.length; i++){

            //第i天手上是现金，要么是第i-1天手上是现金且休息，要么是第i-1天手上是股票然后卖出
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+prices[i]);
            //第i天手上是股票，要么第i-1天手术是股票且休息，要么第i-1天手上是现金然后买入
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-prices[i]);
        }

        return dp[prices.length-1][0];
    }
}
```

## 123. 最多买卖两次

1. 状态定义

   dp[i][j][k] 表示在 [0, i] 区间里（状态具有前缀性质），交易进行了 j 次，并且状态为 k 时我们拥有的现金数。其中 j 和 k 的含义如下：

   - j = 0 表示没有交易发生；
   - j = 1 表示此时已经发生了 1 次买入股票的行为；
   - j = 2 表示此时已经发生了 2 次买入股票的行为。

   即我们 人为规定 记录一次交易产生是在 买入股票 的时候。

   - k = 0 表示当前不持股；
   - k = 1 表示当前持股。

2. 状态转移方程

   - 状态从持有现金（cash）开始，到最后一天我们关心的状态依然是持有现金（cash），即 Math.max(dp[length-1][1][0], dp[length-1][2][0]);
   - 第 i 天可能的操作：**买入、卖出、休息**。注意，**卖出必须先买入**

   1. 第 i 天手上是现金，买卖次数为 0
      dp[i][0][0] = 0;
   2. 第 i 天完成了第一次买卖，手上持有股票 or 没有股票

   ```java
   //手上持有股票
   //1. 第i-1天进行第1次买入，手上有股票 + 第i天休息
   //2. 第i-1天进行过0次买卖，手上没有股票 + 第i天第一次买入
    dp[i][1][1] = Math.max(dp[i-1][1][1], -prices[i]);

   //手上没有股票
   //1. 第i-1天进行过第1次买卖，手上没有股票 + 第i天休息
   //2. 第i-1天进行过第一次买入，手上有股票 + 第i天卖出
   dp[i][1][0] = Math.max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]);
   ```

   3. 第 i 天完成两次买卖，手上持有股票 or 没有股票

   ```java
   //手上持有股票
   //1. 第i-1天进行第二次买入 + 第i天休息
   //2. 第i-1天进行过1次买卖，手上没有股票 + 第i天第二次买入
   dp[i][2][1] = Math.max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])；

   //手上没有股票
   //1. 第i-1天完成了两次买卖 + 第i天休息
   //2. 第i-1天完成了第二次买入 + 第i天卖出
   dp[i][2][0] = Math.max(dp[i-1][2][0], dp[i-1][2][1] + prices[i]);
   ```

3. 确定初始化

   下标为 0 这一天，交易次数为 0、1、2 并且状态为 0 和 1 的初值应该如下设置：

   1）交易 0 次

   - dp[0][0][0] = 0：这是显然的；
   - dp[0][0][1]：表示一次交易都没有发生，但是持股，这是不可能的，也不会有后序的决策要用到这个状态值，可以不用管；

   2）交易 1 次

   - dp[0][1][0] = 0：表示发生了 1 次交易，但是不持股，这在下标为 0 的这天是不可能的。虽然没有意义，但是设置成 0 不会影响最优值；
   - dp[0][1][1] = -prices[0]：表示发生了一次交易，并且持股，即在下标为 0 的这天买入，所以我们持有的现金数就是当天股价的相反数；

   3）交易 2 次

   - dp[0][2][0] = 0：表示发生了 2 次交易，但是不持股，这在下标为 0 的这天是不可能的。虽然没有意义，但是设置成 0 不会影响最优值；
   - dp[0][2][1] = 负无穷：表示发生了 2 次交易，并且持股，这在下标为 0 的这天是不可能的。  
     注意：虽然没有意义，但是不能设置成 0，这是因为交易还没有发生，必须规定当天 k 状态为 1（持股），需要参考以往的状态转移，一种很有可能的情况是没有交易是最好的情况。

   说明：dp[0][2][1] 设置成为负无穷这件事情我可能没有说清楚。大家可以通过特殊测试用例 [1, 2, 3, 4, 5]，对比 dp[0][2][1] = 0 与 dp[0][2][1] = 负无穷 的状态转移的差异去理解。
