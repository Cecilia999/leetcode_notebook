// 题目大意
// 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。
// 输入: 5
// 输出: [0,1,1,2,1,2]

// 解题思路：
// 对于所有的数字，只有两类：
// 1. 奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。
// 举例： 
// 0 = 0       1 = 1
// 2 = 10      3 = 11

// 2. 偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。
// 举例：
// 2 = 10       4 = 100       8 = 1000
// 3 = 11       6 = 110       12 = 1100

class Solution {
    public int[] countBits(int n) {
        int[] bitcounts = new int[n+1];
        bitcounts[0] = 0;
            
        for(int i=1; i<=n; i++){
            //奇数一定比他的前一个偶数多一个1
            if(i%2==1)
                bitcounts[i] = bitcounts[i-1] + 1;
            
            //偶数n的1's的数量 = n/2的那个偶数的1's的数量
            //因为n/2 == n>>1;
            //偶数的least bit最低位为0所以向右shift一位，1's的数量不变
            else
                bitcounts[i] = bitcounts[i/2];
        }
        
        return bitcounts;
    }
}