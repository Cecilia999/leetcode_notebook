# Linked List

### 通用思路：

巧妙的构造虚拟头结点。可以使遍历处理逻辑更加统一。  
灵活使用递归。构造递归条件，使用递归可以巧妙的解题。不过需要注意有些题目不能使用递归，因为递归深度太深会导致超时和栈溢出。

### 1. 链表区间逆序

- [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)：  
  [java](/solution_java/0206_Reverse_Linked_List.java)
- [从尾到头打印链表](https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&&tqId=11156&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking):  
  [java](/牛客网/从尾到头打印链表.java)
- [92 Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/):  
  [java](/solution_java/0092_Reverse_Linked_List_II.java)

### 2. 链表寻找中间节点/链表寻找倒数第 n 个节点

- [19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/):  
  [java](/solution_java/0019_Remove_Nth_Node_From_End_of_List.java)
- [链表中倒数最后 k 个结点](https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=13&&tqId=11167&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking):  
  [java](/牛客网/链表中倒数最后k个结点.java)

只需要一次遍历就可以得到答案。
